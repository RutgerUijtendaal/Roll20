/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/env.ts":
/*!********************!*\
  !*** ./src/env.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logLevel = 'info';\nexports.environment = 'prod';\nexports.botName = 'Jimmy';\nexports.stressModifier = 5;\nexports.modules = ['stress'];\n\n\n//# sourceURL=webpack:///./src/env.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst env_1 = __webpack_require__(/*! ./env */ \"./src/env.ts\");\nconst Stress_1 = __webpack_require__(/*! ./stress/Stress */ \"./src/stress/Stress.ts\");\nenv_1.modules.forEach(_module => {\n    switch (_module) {\n        case 'stress':\n            new Stress_1.Stress();\n            break;\n        default:\n            break;\n    }\n});\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/shared/Chatter.ts":
/*!*******************************!*\
  !*** ./src/shared/Chatter.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/env.ts\");\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/shared/Logger.ts\");\nconst Roll20Util_1 = __webpack_require__(/*! ./Roll20Util */ \"./src/shared/Roll20Util.ts\");\n/**\n * Chatter provides a basic interface for sending messages through the Roll20 chat.\n */\nclass Chatter {\n    constructor() {\n        this.name = env_1.botName || 'Nameless bot';\n    }\n    /**\n     *\n     * @param playerId\n     * @param message\n     */\n    sendFeedback(playerId, message) {\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerId), message);\n    }\n    /**\n     * sendBotWhisper provides a way of sending whispers to a specified Player.\n     *\n     * Whispers are based on the display name of a player. A utility function exists to get\n     * the display name by it's id. {@link Roll20Util#getPlayerDisplayNameById}.\n     *\n     * @param to The display name of a Player\n     * @param content Body of the message\n     * @param archive optional. If a message should be archived. Defaults to false.\n     */\n    sendBotWhisper(to, content, archive = false) {\n        Logger_1.Logger.debug(`Sending whisper '${content}' to ${to}`);\n        const message = `/w \"${to}\" ${content}`;\n        sendChat(this.name, message, null, { noarchive: !archive });\n    }\n    /**\n     * sendBotAnnouncment provides a way of sending a broadcast to everyone in the game\n     * through the chat.\n     *\n     * @param message body of message\n     * @param archive optional. If a message should be archived. Defaults to false.\n     */\n    sendBotAnnouncement(message, archive = false) {\n        Logger_1.Logger.debug(`Sending message ${message}`);\n        sendChat(this.name, message, null, { noarchive: !archive });\n    }\n    stringFormat(str, ...args) {\n        return str.replace(/{(\\d+)}/g, (_match, index) => args[index] || '');\n    }\n}\nexports.Chatter = Chatter;\n\n\n//# sourceURL=webpack:///./src/shared/Chatter.ts?");

/***/ }),

/***/ "./src/shared/Logger.ts":
/*!******************************!*\
  !*** ./src/shared/Logger.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/env.ts\");\n/**\n * Logger is a simple static class that expands on the existing Roll20 log system\n * to allow for different levels of logging.\n */\nclass Logger {\n    static debug(message) {\n        if (env_1.logLevel === 'debug') {\n            log(`DEBUG: ${message}`);\n        }\n    }\n    static info(message) {\n        if (env_1.logLevel === 'debug' || env_1.logLevel === 'info') {\n            log(`INFO: ${message}`);\n        }\n    }\n    static error(message) {\n        if (env_1.logLevel === 'debug' || env_1.logLevel === 'info' || env_1.logLevel === 'error') {\n            log(`ERROR: ${message}`);\n        }\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack:///./src/shared/Logger.ts?");

/***/ }),

/***/ "./src/shared/ObjectHelper.ts":
/*!************************************!*\
  !*** ./src/shared/ObjectHelper.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ObjectHelper {\n    /**\n     *\n     *\n     * @param array\n     */\n    static hasDuplicates(array) {\n        var valuesSoFar = Object.create(null);\n        for (var i = 0; i < array.length; ++i) {\n            var stressItem = array[i];\n            if (stressItem.id in valuesSoFar) {\n                return true;\n            }\n            valuesSoFar[stressItem.id] = true;\n        }\n        return false;\n    }\n}\nexports.ObjectHelper = ObjectHelper;\n/**\n * Deep copy function for TypeScript.\n * @param T Generic type of target/copied value.\n * @param target Target value to be copied.\n * @see Source project, ts-deeply https://github.com/ykdr2017/ts-deepcopy\n * @see Code pen https://codepen.io/erikvullings/pen/ejyBYg\n */\nObjectHelper.deepCopy = (target) => {\n    if (target === null) {\n        return target;\n    }\n    if (target instanceof Date) {\n        return new Date(target.getTime());\n    }\n    if (target instanceof Array) {\n        const cp = [];\n        target.forEach(v => {\n            cp.push(v);\n        });\n        return cp.map((n) => ObjectHelper.deepCopy(n));\n    }\n    if (typeof target === 'object' && target !== {}) {\n        const cp = Object.assign({}, target);\n        Object.keys(cp).forEach(k => {\n            cp[k] = ObjectHelper.deepCopy(cp[k]);\n        });\n        return cp;\n    }\n    return target;\n};\n\n\n//# sourceURL=webpack:///./src/shared/ObjectHelper.ts?");

/***/ }),

/***/ "./src/shared/Roll20Util.ts":
/*!**********************************!*\
  !*** ./src/shared/Roll20Util.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/shared/Logger.ts\");\n/**\n * Roll20Util provides some often used helper functions for interface with Roll20\n */\nclass Roll20Util {\n    /**\n     * Update the attributes of a character for a {@link StressItem}. If the attribute does not yet exist\n     * (which happens when it's the default value) it is created.\n     *\n     * @param playerCharacter character to modify attributes for.\n     * @param stress item containing attributes to modify and by what amount.\n     */\n    static updateNumericalPropertiesWithValueFromStressItem(playerCharacter, stress, reverse = false) {\n        stress.targetAttributes.forEach(targetAttribute => {\n            if (reverse) {\n                targetAttribute.amount *= -1;\n            }\n            Roll20Util.updateNumericalPropertyWithValue(playerCharacter, targetAttribute.target, targetAttribute.amount);\n        });\n    }\n    /**\n     * Update the attributes of a character for each {@link PerseverenceItem}. If the attribute does not yet exist\n     * (which happens when it's the default value) it is created.\n     *\n     * @param playerCharacter character to modify attributes for.\n     * @param perseverence item containing attributes to modify and by what amount.\n     */\n    static updateNumericalPropertiesWithValueFromPerseverenceItem(playerCharacter, perseverence, reverse = false) {\n        if (perseverence.targetAttributes === undefined) {\n            return;\n        }\n        perseverence.targetAttributes.forEach(targetAttribute => {\n            if (reverse) {\n                targetAttribute.amount *= -1;\n            }\n            Roll20Util.updateNumericalPropertyWithValue(playerCharacter, targetAttribute.target, targetAttribute.amount);\n        });\n    }\n    /**\n     * Get the display name of a player by its id. Useful for whispering a player.\n     *\n     * @param playerId playerId to get the display name for.\n     */\n    static getPlayerDisplayNameById(playerId) {\n        const player = getObj('player', playerId);\n        if (!player) {\n            Logger_1.Logger.error(`Could not find player with ID ${playerId}`);\n            return 'unknown sender';\n        }\n        return player.get('_displayname');\n    }\n    /**\n     * Get the {@link Character} object associated with a token. This requires the token to\n     * have a default character that it represents.\n     *\n     * If the token or represents value don't exist, or if the id isn't a token, this function\n     * returns undefined.\n     *\n     * @param id tokenId to get the associated character for.\n     */\n    static getCharacterFromTokenId(id) {\n        const token = this.getGraphicTokenFromId(id);\n        if (!token) {\n            return;\n        }\n        const character = getObj('character', token.get('represents'));\n        if (!character) {\n            return;\n        }\n        return character;\n    }\n    /**\n     * Get a {@link Handout} on a player by its name. All handouts with this name are\n     * retrieved and then filtered down by playerId. If more than one handout still remain\n     * this function returns undefined.\n     *\n     * @param handoutName name of the handout\n     * @param playerId player to get the handout for.\n     */\n    static getHandoutOnPlayer(handoutName, playerId) {\n        let handouts = findObjs({\n            _type: 'handout',\n            name: handoutName\n        });\n        if (handouts.length === 0) {\n            return;\n        }\n        handouts = handouts.filter(handout => {\n            return handout.get('inplayerjournals').indexOf(playerId) != -1;\n        });\n        if (handouts.length > 1) {\n            Logger_1.Logger.error(`Found more than 1 ability for ${handoutName}, aborting to ensure nothing goes wrong`);\n            return;\n        }\n        return handouts.pop();\n    }\n    /**\n     * Get a list of {@link Handout}s with a specific name. This is non player specific\n     * and returns all handouts found with this name.\n     *\n     * @param handoutName name of the handout to find.\n     */\n    static getHandoutsByName(handoutName) {\n        let handouts = findObjs({\n            _type: 'handout',\n            name: handoutName\n        });\n        if (handouts.length === 0) {\n            return;\n        }\n        return handouts;\n    }\n    /**\n     * Get an ability on a specified character by name. If more tha one ability with this name\n     * exists, or no ability can be found this function returns undefined.\n     *\n     * @param abilityName name of the ability to get.\n     * @param characterId id of the character to get the ability from.\n     */\n    static getAbilityOnCharacter(abilityName, characterId) {\n        const abilities = findObjs({\n            _type: 'ability',\n            _characterid: characterId,\n            name: abilityName\n        });\n        if (abilities.length > 1) {\n            Logger_1.Logger.error(`Found more than 1 ability for ${abilityName}, aborting to ensure nothing goes wrong`);\n            return undefined;\n        }\n        return abilities.pop();\n    }\n    static getGraphicTokenFromId(id) {\n        const graphicObj = getObj('graphic', id);\n        if (graphicObj && graphicObj.get('_subtype') === 'token') {\n            return graphicObj;\n        }\n        return;\n    }\n    static updateNumericalPropertyWithValue(playerCharacter, attributeName, amount) {\n        const property = Roll20Util.findAttributeByNameAndCharacterId(attributeName, playerCharacter.characterId);\n        if (!property) {\n            Logger_1.Logger.error(`Could not find property with name ${attributeName} on character ${playerCharacter.name}, creating...`);\n            Roll20Util.createPropertyWithDefaultValueOnCharacter(playerCharacter, attributeName);\n            // Recursion woooo~\n            Roll20Util.updateNumericalPropertyWithValue(playerCharacter, attributeName, amount);\n            return;\n        }\n        Logger_1.Logger.info(`Modifying property ${attributeName} on character ${playerCharacter.name} with value ${amount}`);\n        const current = +property.get('current');\n        property.setWithWorker('current', String(current + amount));\n    }\n    static createPropertyWithDefaultValueOnCharacter(playerCharacter, attributeName) {\n        const primaryStats = ['strength', 'charisma', 'dexterity', 'wisdom', 'intelligence'];\n        let defaultValue = 0;\n        if (primaryStats.indexOf(attributeName) !== -1) {\n            defaultValue = 10;\n        }\n        const attribute = {\n            _characterid: playerCharacter.characterId,\n            current: '' + defaultValue,\n            name: attributeName\n        };\n        createObj('attribute', attribute);\n    }\n    static findAttributeByNameAndCharacterId(name, characterId) {\n        const attributes = findObjs({\n            _type: 'attribute',\n            _characterid: characterId,\n            name: name\n        });\n        if (attributes.length > 1) {\n            Logger_1.Logger.error(`Found more than 1 attribute result for ${name}, aborting to ensure nothing goes wrong`);\n            return undefined;\n        }\n        return attributes.pop();\n    }\n}\nexports.Roll20Util = Roll20Util;\n\n\n//# sourceURL=webpack:///./src/shared/Roll20Util.ts?");

/***/ }),

/***/ "./src/stress/Stress.ts":
/*!******************************!*\
  !*** ./src/stress/Stress.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StressChatter_1 = __webpack_require__(/*! ./util/StressChatter */ \"./src/stress/util/StressChatter.ts\");\nconst StressAbilityCreator_1 = __webpack_require__(/*! ./util/StressAbilityCreator */ \"./src/stress/util/StressAbilityCreator.ts\");\nconst StressFileWriter_1 = __webpack_require__(/*! ./util/StressFileWriter */ \"./src/stress/util/StressFileWriter.ts\");\nconst StressItemManager_1 = __webpack_require__(/*! ./items/StressItemManager */ \"./src/stress/items/StressItemManager.ts\");\nconst StressStateManager_1 = __webpack_require__(/*! ./persistence/StressStateManager */ \"./src/stress/persistence/StressStateManager.ts\");\nconst StressProcessorService_1 = __webpack_require__(/*! ./services/StressProcessorService */ \"./src/stress/services/StressProcessorService.ts\");\nconst StressNameChangeHandler_1 = __webpack_require__(/*! ./eventhandlers/StressNameChangeHandler */ \"./src/stress/eventhandlers/StressNameChangeHandler.ts\");\nconst StressCommandHandler_1 = __webpack_require__(/*! ./eventhandlers/StressCommandHandler */ \"./src/stress/eventhandlers/StressCommandHandler.ts\");\nclass Stress {\n    constructor() {\n        this.chatter = new StressChatter_1.StressChatter();\n        this.stressAbilityCreator = new StressAbilityCreator_1.StressAbilityCreator();\n        this.stressFileWriter = new StressFileWriter_1.StressFileWriter();\n        this.stressItemManager = new StressItemManager_1.StressItemManager();\n        this.stressStateManager = new StressStateManager_1.StressStateManager();\n        this.stressProcessor = new StressProcessorService_1.StressProcessorService(this.stressStateManager, this.stressFileWriter, this.stressItemManager, this.chatter);\n        this.stressNamechangeHandler = new StressNameChangeHandler_1.StressNameChangeHandler(this.stressStateManager, this.stressFileWriter);\n        this.stressCommandHandler = new StressCommandHandler_1.StressCommandHandler(this.stressStateManager, this.stressProcessor, this.stressAbilityCreator, this.stressFileWriter, this.chatter);\n    }\n}\nexports.Stress = Stress;\n\n\n//# sourceURL=webpack:///./src/stress/Stress.ts?");

/***/ }),

/***/ "./src/stress/eventhandlers/StressCommandHandler.ts":
/*!**********************************************************!*\
  !*** ./src/stress/eventhandlers/StressCommandHandler.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Roll20Util_1 = __webpack_require__(/*! ../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nclass StressCommandHandler {\n    constructor(stressStateManager, stressProcessor, stressAbilityCreator, stressFileWriter, chatter) {\n        this.stressStateManager = stressStateManager;\n        this.stressProcessor = stressProcessor;\n        this.stressAbilityCreator = stressAbilityCreator;\n        this.stressFileWriter = stressFileWriter;\n        this.chatter = chatter;\n        this.register();\n    }\n    register() {\n        Logger_1.Logger.info('Registering Stress Command Handler');\n        on('chat:message', (message) => {\n            this.handle(message);\n        });\n    }\n    handle(message) {\n        if (message.type !== 'api') {\n            return;\n        }\n        if (message.content.indexOf('!+-stress') === -1 && message.content.indexOf('!perseverence') === -1) {\n            return;\n        }\n        const playerCharacter = this.extractPlayerCharacterFromMessage(message);\n        if (message.content.indexOf('!stress') !== -1 && playerCharacter) {\n            this.handleNewStressCharacter(playerCharacter);\n        }\n        else if (!playerCharacter) {\n            return;\n        }\n        const stressedCharacter = this.findStressedCharacterByPlayerCharacter(playerCharacter);\n        if (message.content.indexOf('!+-stress') !== -1 && stressedCharacter) {\n            this.handleStressUpdate(message, stressedCharacter);\n        }\n        if (message.content.indexOf('!perseverence') !== -1 && stressedCharacter) {\n            this.handlePerseverenceUpdate(message, stressedCharacter);\n        }\n    }\n    handleNewStressCharacter(playerCharacter) {\n        const stressedCharacter = this.stressStateManager.addNewStressedCharacter(playerCharacter);\n        if (stressedCharacter !== undefined) {\n            this.stressAbilityCreator.createStressAbilityOnCharacter(playerCharacter);\n            this.stressFileWriter.createEmptyStressNote(playerCharacter);\n            this.chatter.sendWelcomeMessage(playerCharacter);\n        }\n    }\n    handleStressUpdate(message, stressedCharacter) {\n        const amount = this.extractStressAmount(message.content);\n        if (!amount) {\n            this.chatter.sendFeedback(stressedCharacter.playerId, `Amount can only be numbers`);\n            return;\n        }\n        if (amount > 0) {\n            this.handleAddStress(amount, stressedCharacter);\n        }\n        else {\n            this.handleRemoveStress(amount, stressedCharacter);\n        }\n    }\n    handlePerseverenceUpdate(message, stressedCharacter) {\n        const uuid = this.extractPerseverenceUuid(message.content);\n        this.stressProcessor.processPerseverenceRemoval(stressedCharacter, uuid);\n    }\n    handleAddStress(amountToAdd, stressedCharacter) {\n        this.stressProcessor.processStressGain(Object.assign(Object.assign({}, stressedCharacter), { amount: amountToAdd, oldStressValue: stressedCharacter.stressValue }));\n    }\n    handleRemoveStress(amountToRemove, stressedCharacter) {\n        this.stressProcessor.processStressLoss(Object.assign(Object.assign({}, stressedCharacter), { amount: amountToRemove, oldStressValue: stressedCharacter.stressValue }));\n    }\n    extractPerseverenceUuid(message) {\n        return message.substr(message.indexOf(' ') + 1);\n    }\n    extractStressAmount(message) {\n        const numbersRegex = /^-?[0-9]+$/;\n        const amount = message.substr(message.indexOf(' ') + 1);\n        if (amount.match(numbersRegex)) {\n            return +amount;\n        }\n        return;\n    }\n    extractPlayerCharacterFromMessage(message) {\n        const apiChatEvent = message;\n        if (!apiChatEvent.selected || apiChatEvent.selected.length !== 1) {\n            this.chatter.sendFeedback(message.playerid, 'Make sure to only select 1 token. And that token is associated with a character.');\n            return;\n        }\n        const character = Roll20Util_1.Roll20Util.getCharacterFromTokenId(apiChatEvent.selected[0]._id);\n        // Make sure the token info is correct\n        if (!character) {\n            return;\n        }\n        const playerCharacter = {\n            characterId: character.get('_id'),\n            playerId: message.playerid,\n            name: character.get('name')\n        };\n        return playerCharacter;\n    }\n    findStressedCharacterByPlayerCharacter(playerCharacter) {\n        const stressedCharacter = this.stressStateManager.getStressedCharacter(playerCharacter);\n        // Make sure we have this character registered\n        if (!stressedCharacter) {\n            Logger_1.Logger.error(`Tried to add stress for unknown character: ${playerCharacter.name}`);\n            return;\n        }\n        return stressedCharacter;\n    }\n}\nexports.StressCommandHandler = StressCommandHandler;\n\n\n//# sourceURL=webpack:///./src/stress/eventhandlers/StressCommandHandler.ts?");

/***/ }),

/***/ "./src/stress/eventhandlers/StressNameChangeHandler.ts":
/*!*************************************************************!*\
  !*** ./src/stress/eventhandlers/StressNameChangeHandler.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nclass StressNameChangeHandler {\n    constructor(stressStateManager, stressFileWriter) {\n        this.stressStateManager = stressStateManager;\n        this.stressFileWriter = stressFileWriter;\n        this.register();\n    }\n    register() {\n        Logger_1.Logger.info('Registering Stress Name Change Handler');\n        on('change:character', (cur, prev) => {\n            if (cur.get('name') !== prev.name) {\n                this.handle(cur, prev);\n            }\n        });\n    }\n    handle(cur, prev) {\n        const stressedCharacter = this.stressStateManager.getStressedCharacter({\n            characterId: cur.id,\n            playerId: '',\n            name: '',\n        });\n        if (!stressedCharacter) {\n            return;\n        }\n        stressedCharacter.name = cur.get('name');\n        Logger_1.Logger.info(`Changed name ${prev.name} to ${stressedCharacter.name}`);\n        this.stressStateManager.updateStressedCharacter(stressedCharacter);\n        this.stressFileWriter.updateStressNoteName(prev.name, stressedCharacter.name);\n    }\n}\nexports.StressNameChangeHandler = StressNameChangeHandler;\n\n\n//# sourceURL=webpack:///./src/stress/eventhandlers/StressNameChangeHandler.ts?");

/***/ }),

/***/ "./src/stress/items/StressItemManager.ts":
/*!***********************************************!*\
  !*** ./src/stress/items/StressItemManager.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StressItems_1 = __webpack_require__(/*! ./StressItems */ \"./src/stress/items/StressItems.ts\");\nconst ObjectHelper_1 = __webpack_require__(/*! ../../shared/ObjectHelper */ \"./src/shared/ObjectHelper.ts\");\nconst StressPerseverenceItems_1 = __webpack_require__(/*! ./StressPerseverenceItems */ \"./src/stress/items/StressPerseverenceItems.ts\");\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\n/**\n * StressItemManager is a utility class for getting {@link StressItem}s and\n * {@link PerseverenceItem}s.\n *\n * Because different items have different weights a rolltable is build from all\n * available items, accounting for different weights, which is then rolled against.\n */\nclass StressItemManager {\n    constructor() {\n        this.rollTableTotal = [];\n        this.rollTableStress = [];\n        this.rollTablePerseverence = [];\n        this.buildRollTable();\n    }\n    /**\n     * Picks randomly from the entire table and returns if a {@link PerseverenceItem} was hit.\n     */\n    isPerseverence() {\n        return (this.rollTableTotal[this.getRandomNumberForSize(this.rollTableTotal.length)].type ===\n            'perseverence');\n    }\n    /**\n     * Returns a randomly selected {@link StressItem} from the available rolltable.\n     */\n    getRandomStress() {\n        // Have to make deep copies to make sure we're not constantly referencing the same obj.\n        return ObjectHelper_1.ObjectHelper.deepCopy(this.rollTableStress[this.getRandomNumberForSize(this.rollTableStress.length)]);\n    }\n    /**\n     * Returns a randomly selected {@link PerseverenceItem} from the available rolltable.\n     *\n     * A UUID is added to the item, in order for it to be removable later without worrying about\n     * removing duplicates.\n     */\n    getRandomPerseverence() {\n        // Have to make deep copies to make sure we're not constantly referencing the same obj.\n        const perseverence = ObjectHelper_1.ObjectHelper.deepCopy(this.rollTablePerseverence[this.getRandomNumberForSize(this.rollTablePerseverence.length)]);\n        perseverence.uuid = this.randomUuid();\n        return perseverence;\n    }\n    buildRollTable() {\n        Logger_1.Logger.info('Building roll table');\n        StressItems_1.stresses.forEach(stressItem => {\n            for (let index = 0; index < stressItem.weight; index++) {\n                this.rollTableTotal.push(stressItem);\n                this.rollTableStress.push(stressItem);\n            }\n        });\n        StressPerseverenceItems_1.perseverences.forEach(perseverenceItem => {\n            for (let index = 0; index < perseverenceItem.weight; index++) {\n                this.rollTableTotal.push(perseverenceItem);\n                this.rollTablePerseverence.push(perseverenceItem);\n            }\n        });\n        Logger_1.Logger.debug(`Roll table size: ${this.rollTableTotal.length}`);\n    }\n    getRandomNumberForSize(size) {\n        return randomInteger(size) - 1;\n    }\n    randomUuid() {\n        const uuid = '_' + Math.random().toString(36).substr(2, 9);\n        Logger_1.Logger.debug(`generated uuid ${uuid}`);\n        return uuid;\n    }\n}\nexports.StressItemManager = StressItemManager;\n\n\n//# sourceURL=webpack:///./src/stress/items/StressItemManager.ts?");

/***/ }),

/***/ "./src/stress/items/StressItems.ts":
/*!*****************************************!*\
  !*** ./src/stress/items/StressItems.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stressStrength = {\n    id: 1,\n    type: 'debuff',\n    name: '-2 to Strength',\n    weight: 2,\n    targetAttributes: [{ name: 'Stength', target: 'strength', amount: -2 }]\n};\nconst stressCharisma = {\n    id: 2,\n    type: 'debuff',\n    name: '-2 to Charisma',\n    weight: 2,\n    targetAttributes: [{ name: 'Charisma', target: 'charisma', amount: -2 }]\n};\nconst stressIntelligence = {\n    id: 3,\n    type: 'debuff',\n    name: '-2 to Intelligence',\n    weight: 2,\n    targetAttributes: [{ name: 'Intelligence', target: 'intelligence', amount: -2 }]\n};\nconst stressWisdom = {\n    id: 4,\n    type: 'debuff',\n    name: '-2 to Wisdom',\n    weight: 2,\n    targetAttributes: [{ name: 'Wisdom', target: 'wisdom', amount: -2 }]\n};\nconst stressDexterity = {\n    id: 5,\n    type: 'debuff',\n    name: '-2 to Dexterity',\n    weight: 2,\n    targetAttributes: [{ name: 'Dexterity', target: 'dexterity', amount: -2 }]\n};\nconst stressToHit = {\n    id: 6,\n    type: 'debuff',\n    name: '-1 to Hit',\n    weight: 1,\n    targetAttributes: [\n        { name: 'Melee Attack Bonus', target: 'global_melee_attack_bonus', amount: -1 },\n        { name: 'Ranged Attack Bonus', target: 'global_ranged_attack_bonus', amount: -1 }\n    ]\n};\nconst stressDamage = {\n    id: 7,\n    type: 'debuff',\n    name: '-1 to Damage',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Melee Damage Bonus', target: 'global_melee_damage_bonus', amount: -1 },\n        { name: 'Ranged Damage Bonus', target: 'global_ranged_damage_bonus', amount: -1 }\n    ]\n};\nconst stressSavingThrow = {\n    id: 8,\n    type: 'debuff',\n    name: '-1 to Saving Throws',\n    weight: 1,\n    targetAttributes: [{ name: 'Saving Throws', target: 'global_saving_bonus', amount: -1 }]\n};\nconst stressPerception = {\n    id: 9,\n    type: 'debuff',\n    name: '-1 to Perception',\n    weight: 2,\n    targetAttributes: [{ name: 'Perception', target: 'perception_bonus', amount: -1 }]\n};\nconst stressAthletics = {\n    id: 10,\n    type: 'debuff',\n    name: '-1 to Athletics',\n    weight: 1,\n    targetAttributes: [{ name: 'Atheletics', target: 'athletics_bonus', amount: -1 }]\n};\nconst stressAcrobaticsAndPerformance = {\n    id: 11,\n    type: 'debuff',\n    name: '-1 to Acrobatics & Performance',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Acrobatics', target: 'acrobatics_bonus', amount: -1 },\n        { name: 'Performance', target: 'performance_bonus', amount: -1 }\n    ]\n};\nconst stressStealthAndSlightOfHand = {\n    id: 12,\n    type: 'debuff',\n    name: '-1 to Stealth and Sleight of Hand',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Stealth', target: 'stealth_bonus', amount: -1 },\n        { name: 'Sleight of Hand', target: 'sleightofhand_bonus', amount: -1 }\n    ]\n};\nconst stressInsightAndMedince = {\n    id: 13,\n    type: 'debuff',\n    name: '-1 to Insight and Medicine',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Insight', target: 'insight_bonus', amount: -1 },\n        { name: 'Medicine', target: 'medicine_bonus', amount: -1 }\n    ]\n};\nconst stressHistoryReligionCulture = {\n    id: 14,\n    type: 'debuff',\n    name: '-1 to History, Religion and Culture',\n    weight: 2,\n    targetAttributes: [\n        { name: 'History', target: 'history_bonus', amount: -1 },\n        { name: 'Religion', target: 'religion_bonus', amount: -1 },\n        { name: 'Culture', target: 'custom_skill_1_bonus', amount: -1 }\n    ]\n};\nconst stressInvestigaton = {\n    id: 15,\n    type: 'debuff',\n    name: '-1 to Investigation',\n    weight: 2,\n    targetAttributes: [{ name: 'Investigation', target: 'investigation_bonus', amount: -1 }]\n};\nconst stressPersuasionAndDeception = {\n    id: 16,\n    type: 'debuff',\n    name: '-1 to Persuasion and Deception',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Persuasion', target: 'persuasion_bonus', amount: -1 },\n        { name: 'Deception', target: 'deception_bonus', amount: -1 }\n    ]\n};\nconst stressIntimidaton = {\n    id: 17,\n    type: 'debuff',\n    name: '-2 to Intimidaton',\n    weight: 2,\n    targetAttributes: [{ name: 'Intimidation', target: 'intimidation_bonus', amount: -2 }]\n};\nconst stressInitiative = {\n    id: 18,\n    type: 'debuff',\n    name: '-1 to Initiative',\n    weight: 2,\n    targetAttributes: [{ name: 'Initiative', target: 'initiative', amount: -1 }]\n};\nconst stressSurvivalAndNature = {\n    id: 19,\n    type: 'debuff',\n    name: '-1 to Survival and Nature',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Survival', target: 'nature_bonus', amount: -1 },\n        { name: 'Nature', target: 'survival_bonus', amount: -1 }\n    ]\n};\nconst stressAnimalHandlingIntimidation = {\n    id: 20,\n    type: 'debuff',\n    name: '-2 to Animal Handling, +1 to Intimidation',\n    weight: 2,\n    targetAttributes: [\n        { name: 'Intimidation', target: 'intimidation_bonus', amount: 1 },\n        { name: 'Animal Handling', target: 'animalhandling_bonus', amount: -2 }\n    ]\n};\nexports.stresses = [\n    stressStrength,\n    stressCharisma,\n    stressIntelligence,\n    stressDexterity,\n    stressWisdom,\n    stressToHit,\n    stressDamage,\n    stressSavingThrow,\n    stressPerception,\n    stressAthletics,\n    stressAcrobaticsAndPerformance,\n    stressStealthAndSlightOfHand,\n    stressInsightAndMedince,\n    stressHistoryReligionCulture,\n    stressInvestigaton,\n    stressPersuasionAndDeception,\n    stressIntimidaton,\n    stressInitiative,\n    stressSurvivalAndNature\n];\n\n\n//# sourceURL=webpack:///./src/stress/items/StressItems.ts?");

/***/ }),

/***/ "./src/stress/items/StressPerseverenceItems.ts":
/*!*****************************************************!*\
  !*** ./src/stress/items/StressPerseverenceItems.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst perseverenceRelax = {\n    id: 1,\n    type: 'perseverence',\n    name: 'Relax',\n    desc: '-30 Stress',\n    weight: 1\n};\nconst perseverenceNotToday = {\n    id: 2,\n    type: 'perseverence',\n    name: 'Not Today',\n    desc: 'Death Ward',\n    weight: 1\n};\nconst perseverenceUnstoppable = {\n    id: 3,\n    type: 'perseverence',\n    name: 'Unstoppable',\n    desc: '1 Legendary Resistance',\n    weight: 1\n};\nconst perseverenceEnoughOfThisShit = {\n    id: 4,\n    type: 'perseverence',\n    name: 'Enough of this shit',\n    desc: '+2 to hit, damage and save DCs',\n    targetAttributes: [\n        { name: 'Melee Damage', target: 'global_melee_damage_bonus', amount: 2 },\n        { name: 'Ranged Damage', target: 'global_ranged_damage_bonus', amount: 2 },\n        { name: 'Melee Attack', target: 'global_melee_attack_bonus', amount: 2 },\n        { name: 'Ranged Attack', target: 'global_ranged_attack_bonus', amount: 2 },\n        { name: 'Saving Throws', target: 'global_saving_bonus', amount: 2 }\n    ],\n    weight: 1\n};\nconst perseverenceFocus = {\n    id: 5,\n    type: 'perseverence',\n    name: 'Focus',\n    desc: '+2 to all skill checks',\n    targetAttributes: [{ name: 'Skill Checks', target: 'global_check_bonus', amount: 2 }],\n    weight: 1\n};\nexports.perseverences = [\n    perseverenceRelax,\n    perseverenceNotToday,\n    perseverenceUnstoppable,\n    perseverenceEnoughOfThisShit,\n    perseverenceFocus\n];\n\n\n//# sourceURL=webpack:///./src/stress/items/StressPerseverenceItems.ts?");

/***/ }),

/***/ "./src/stress/persistence/StressStateManager.ts":
/*!******************************************************!*\
  !*** ./src/stress/persistence/StressStateManager.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nconst env_1 = __webpack_require__(/*! ../../env */ \"./src/env.ts\");\n/**\n * StressStateManager handles persisting Stress data.\n *\n * An array of {@link StressedCharacter}s is persisted and can be queried against.\n */\nclass StressStateManager {\n    constructor() {\n        Logger_1.Logger.info('Initialize StressManager');\n        if (env_1.environment === 'test') {\n            Logger_1.Logger.info('Starting fresh with stressManager');\n            state.StressNS = null;\n        }\n        if (!state.StressNS) {\n            this.initializeState();\n        }\n        else if (env_1.environment === 'test') {\n            this.debugState();\n        }\n    }\n    /**\n     * Returns the state object.\n     */\n    getState() {\n        return state.StressNS;\n    }\n    /**\n     * Add a new {@link StressedCharacter} to the state. Stress is initialized at 0.\n     * If the character already exists in the state it is silently ignored.\n     *\n     * @param character new character to add. Properties acquired from chat user.\n     */\n    addNewStressedCharacter(playerCharacter) {\n        if (this.characterExists(playerCharacter)) {\n            Logger_1.Logger.error(`Tried adding existing character to StressState: ${playerCharacter.name}`);\n            return;\n        }\n        const stressedCharacter = Object.assign(Object.assign({}, playerCharacter), { stressValue: 0, stresses: [], perseverences: [] });\n        state.StressNS.characters.push(stressedCharacter);\n        Logger_1.Logger.info(`Added new character ${playerCharacter.name} to StressState`);\n        return stressedCharacter;\n    }\n    /**\n     * Updates an existing {@link StressedCharacter} with new values. Overwrites the whole\n     * object. Updating is based on character id.\n     *\n     * If the character can't be found this function exits silently.\n     *\n     * @param stressedCharacter StressedCharacter to update.\n     */\n    updateStressedCharacter(stressedCharacter) {\n        if (!this.characterExists(stressedCharacter)) {\n            Logger_1.Logger.error(`Attempted to update unknown character: ${stressedCharacter.name}`);\n            return;\n        }\n        this.getState().characters[this.findCharacterIndex(stressedCharacter)] = stressedCharacter;\n    }\n    /**\n     * Get a {@link StressedCharacter} from the persisted state based on a {@link PlayerCharacter}.\n     * Finding a character is based on character id.\n     *\n     * If no character can be found returns undefined instead.\n     *\n     * @param character\n     */\n    getStressedCharacter(character) {\n        if (!this.characterExists(character)) {\n            return undefined;\n        }\n        return state.StressNS.characters[this.findCharacterIndex(character)];\n    }\n    characterExists(character) {\n        return this.findCharacterIndex(character) !== -1;\n    }\n    findCharacterIndex(character) {\n        const index = state.StressNS.characters.findIndex((_character) => {\n            return _character.characterId === character.characterId;\n        });\n        return index;\n    }\n    debugState() {\n        this.getState().characters.forEach((char) => {\n            Logger_1.Logger.debug(`char: ${char.name} with stresses:`);\n            char.stresses.forEach((stress) => {\n                Logger_1.Logger.debug(`${stress.name}`);\n                if (stress.mixin !== undefined) {\n                    Logger_1.Logger.debug(`And mixin: ${stress.mixin.name}`);\n                }\n            });\n        });\n    }\n    initializeState() {\n        Logger_1.Logger.info('Creating new empty stress states');\n        state.StressNS = {\n            version: 1.0,\n            characters: []\n        };\n    }\n}\nexports.StressStateManager = StressStateManager;\n\n\n//# sourceURL=webpack:///./src/stress/persistence/StressStateManager.ts?");

/***/ }),

/***/ "./src/stress/services/StressProcessorService.ts":
/*!*******************************************************!*\
  !*** ./src/stress/services/StressProcessorService.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst env_1 = __webpack_require__(/*! ../../env */ \"./src/env.ts\");\nconst StressAdditionService_1 = __webpack_require__(/*! ./stress-items/StressAdditionService */ \"./src/stress/services/stress-items/StressAdditionService.ts\");\nconst StressRemovalService_1 = __webpack_require__(/*! ./stress-items/StressRemovalService */ \"./src/stress/services/stress-items/StressRemovalService.ts\");\nconst StressPerseverenceRemovalService_1 = __webpack_require__(/*! ./perseverence-items/StressPerseverenceRemovalService */ \"./src/stress/services/perseverence-items/StressPerseverenceRemovalService.ts\");\nconst StressPerseverenceAdditionService_1 = __webpack_require__(/*! ./perseverence-items/StressPerseverenceAdditionService */ \"./src/stress/services/perseverence-items/StressPerseverenceAdditionService.ts\");\nconst ObjectHelper_1 = __webpack_require__(/*! ../../shared/ObjectHelper */ \"./src/shared/ObjectHelper.ts\");\n/**\n * StressProcessorService is the entry point for handling new {@link StressUpdate}s.\n *\n * This class holds reference to {@link StressAdditionService}, {@link StressRemovalService},\n * {@link StressPerseverenceAdditionService} and {@link StressPerseverenceRemovalService} and\n * delegates to the correct one depending on Stress rolls and update amounts.\n */\nclass StressProcessorService {\n    constructor(stressStateManager, stressFileWriter, stressItemManager, chatter) {\n        this.stressModifier = env_1.stressModifier || 5;\n        this.stressStateManager = stressStateManager;\n        this.stressItemManager = stressItemManager;\n        this.stressFileWriter = stressFileWriter;\n        this.stressAdditionService = new StressAdditionService_1.StressAdditionService(stressItemManager, chatter);\n        this.stressRemovalService = new StressRemovalService_1.StressRemovalService(stressItemManager, chatter);\n        this.stressPerseverenceRemovalService = new StressPerseverenceRemovalService_1.StressPerseverenceRemovalService(stressItemManager, this, chatter);\n        this.stressPerseverenceAdditionService = new StressPerseverenceAdditionService_1.StressPerseverenceAdditionService(stressItemManager, this, chatter);\n        this.chatter = chatter;\n    }\n    /**\n     * Add stress to a {@link StressedCharacter}. If Stress reaches a breakpoint (based on\n     * stressModifier) rolls are made for each breakpoint reached to determine if a character\n     * should get a Stress debuff or Perseverence buff. Depending on the roll it adds either.\n     *\n     * @param stressUpdate obj containing who to update stress for and by what amount.\n     */\n    processStressGain(stressUpdate) {\n        for (let index = 0; index < ObjectHelper_1.ObjectHelper.deepCopy(stressUpdate).amount; index++) {\n            stressUpdate.stressValue += 1;\n            if (stressUpdate.stressValue % env_1.stressModifier === 0) {\n                if (this.stressItemManager.isPerseverence()) {\n                    stressUpdate.stressValue -= 5;\n                    stressUpdate = this.stressPerseverenceAdditionService.addPerseverenceItem(stressUpdate);\n                }\n                else {\n                    stressUpdate = this.stressAdditionService.addStressItem(stressUpdate);\n                }\n            }\n        }\n        return this.postProcessing(stressUpdate);\n    }\n    /**\n     * Remove stress from a character. If Stress reaches a breakpoint (based on\n     * stressModifier) {@link StressItem} are removed from a character.\n     *\n     * @param stressUpdate obj containing who to update stress for and by what amount.\n     * @param internal optional. If true does not trigger a whisper to a player. Default false.\n     */\n    processStressLoss(stressUpdate) {\n        // If stress is already 0 we don't have to do anything\n        if (stressUpdate.stressValue === 0) {\n            return stressUpdate;\n        }\n        for (let index = ObjectHelper_1.ObjectHelper.deepCopy(stressUpdate).amount; index < 0; index++) {\n            stressUpdate.stressValue = Math.max((stressUpdate.stressValue - 1), 0);\n            if ((stressUpdate.stressValue + 1) % env_1.stressModifier === 0) {\n                stressUpdate = this.stressRemovalService.removeStressItem(stressUpdate);\n            }\n        }\n        return this.postProcessing(stressUpdate);\n    }\n    /**\n     * Remove a {@link PerseverenceItem} from a character. Item to remove is based on the\n     * UUID.\n     *\n     * @param stressedCharacter character to remove perseverence from.\n     * @param uuid unique id of the perseverence to remove.\n     */\n    processPerseverenceRemoval(stressedCharacter, uuid) {\n        stressedCharacter = this.stressPerseverenceRemovalService.removePerseverenceItem(stressedCharacter, uuid);\n        this.postProcessing(Object.assign(Object.assign({}, stressedCharacter), { amount: 0, oldStressValue: stressedCharacter.stressValue }));\n    }\n    postProcessing(stressUpdate) {\n        if (stressUpdate.amount !== 0) {\n            this.chatter.sendStressChangedMessage(stressUpdate);\n        }\n        this.stressStateManager.updateStressedCharacter(stressUpdate);\n        this.stressFileWriter.updateStressNoteForStressedCharacter(stressUpdate);\n        return stressUpdate;\n    }\n}\nexports.StressProcessorService = StressProcessorService;\n\n\n//# sourceURL=webpack:///./src/stress/services/StressProcessorService.ts?");

/***/ }),

/***/ "./src/stress/services/perseverence-items/StressPerseverenceAdditionService.ts":
/*!*************************************************************************************!*\
  !*** ./src/stress/services/perseverence-items/StressPerseverenceAdditionService.ts ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Roll20Util_1 = __webpack_require__(/*! ../../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\n/**\n * StressPerseverenceAdditionService handles adding new {@link PerseverenceItems}\n * to a {@link StressedCharacter}.\n *\n * It is furthermore responsible for calling the effect on an item it adds.\n *\n * Note that because PerseverenceItems are unique in their effect it's basically a giant\n * switch statement over the item ids to call their effects.\n */\nclass StressPerseverenceAdditionService {\n    constructor(stressItemManager, stressProcessorService, chatter) {\n        this.stressItemManager = stressItemManager;\n        this.stressProcessorService = stressProcessorService;\n        this.chatter = chatter;\n    }\n    /**\n     * Adds a randomly selected{@link PerseverenceItem} to a Character.\n     *\n     * Also handles the effect of the item.\n     *\n     * @param stressUpdate\n     */\n    addPerseverenceItem(stressUpdate) {\n        const perseverence = this.stressItemManager.getRandomPerseverence();\n        stressUpdate = this.doPerseverenceEffect(stressUpdate, perseverence);\n        this.chatter.sendPerseverenceGainedMessage(stressUpdate, perseverence);\n        return stressUpdate;\n    }\n    doPerseverenceEffect(stressUpdate, perseverence) {\n        switch (perseverence.id) {\n            case 1: // Relax\n                stressUpdate.perseverences.push(perseverence);\n                break;\n            case 2: // Not Today\n                stressUpdate.perseverences.push(perseverence);\n                break;\n            case 3: // Unstoppable\n                stressUpdate.perseverences.push(perseverence);\n                break;\n            case 4: // Enough of this shit\n                Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromPerseverenceItem(stressUpdate, perseverence);\n                stressUpdate.perseverences.push(perseverence);\n                break;\n            case 5: // Focus\n                Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromPerseverenceItem(stressUpdate, perseverence);\n                stressUpdate.perseverences.push(perseverence);\n                break;\n            default:\n                break;\n        }\n        return stressUpdate;\n    }\n}\nexports.StressPerseverenceAdditionService = StressPerseverenceAdditionService;\n\n\n//# sourceURL=webpack:///./src/stress/services/perseverence-items/StressPerseverenceAdditionService.ts?");

/***/ }),

/***/ "./src/stress/services/perseverence-items/StressPerseverenceRemovalService.ts":
/*!************************************************************************************!*\
  !*** ./src/stress/services/perseverence-items/StressPerseverenceRemovalService.ts ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Roll20Util_1 = __webpack_require__(/*! ../../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\nconst Logger_1 = __webpack_require__(/*! ../../../shared/Logger */ \"./src/shared/Logger.ts\");\n/**\n * StressPerseverenceRemovalService handles removing {@link PerseverenceItem}s from a\n * {@link StressedCharacter}.\n *\n * It is furthermore responsible for removing the effect on an item it removes.\n *\n * Note that because PerseverenceItems are unique in their effect it's basically a giant\n * switch statement over the item ids to call their effects.\n */\nclass StressPerseverenceRemovalService {\n    constructor(stressItemManager, stressProcessorService, chatter) {\n        this.stressItemManager = stressItemManager;\n        this.stressProcessorService = stressProcessorService;\n        this.chatter = chatter;\n    }\n    /**\n     * Remove a {@link PerseverenceItem} from a character. Undoes the effect and removes it from the\n     * array of perseverences.\n     *\n     * The PerseverenceItem removed is based on a unique UUID that was generated when it was added.\n     *\n     * If the perseverence can not be found this function returns quietly\n     *\n     * @param stressedCharacter Character to remove the item from\n     * @param uuid Unique id of the perseverence item to remove\n     */\n    removePerseverenceItem(stressedCharacter, uuid) {\n        const index = stressedCharacter.perseverences.findIndex(perseverence => perseverence.uuid === uuid);\n        if (index === -1) {\n            Logger_1.Logger.error(`Couldn't find perseverence on character ${stressedCharacter.name} with id ${uuid}`);\n            return stressedCharacter;\n        }\n        const perseverence = stressedCharacter.perseverences[index];\n        stressedCharacter = this.undoPerseverenceEffect(stressedCharacter, perseverence, index);\n        this.chatter.sendPerseverenceLostMessage(stressedCharacter, perseverence);\n        return stressedCharacter;\n    }\n    undoPerseverenceEffect(stressedCharacter, perseverence, index) {\n        switch (perseverence.id) {\n            case 1: // Relax\n                stressedCharacter = this.stressProcessorService.processStressLoss(Object.assign(Object.assign({}, stressedCharacter), { amount: -30, oldStressValue: stressedCharacter.stressValue }));\n                stressedCharacter.perseverences.splice(index, 1);\n                break;\n            case 2: // Not Today\n                stressedCharacter.perseverences.splice(index, 1);\n                break;\n            case 3: // Unstoppable\n                stressedCharacter.perseverences.splice(index, 1);\n                break;\n            case 4: // Enough of this shit\n                Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromPerseverenceItem(stressedCharacter, perseverence, true);\n                stressedCharacter.perseverences.splice(index, 1);\n                break;\n            case 5: // Focus\n                Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromPerseverenceItem(stressedCharacter, perseverence, true);\n                stressedCharacter.perseverences.splice(index, 1);\n                break;\n            default:\n                break;\n        }\n        return stressedCharacter;\n    }\n}\nexports.StressPerseverenceRemovalService = StressPerseverenceRemovalService;\n\n\n//# sourceURL=webpack:///./src/stress/services/perseverence-items/StressPerseverenceRemovalService.ts?");

/***/ }),

/***/ "./src/stress/services/stress-items/StressAdditionService.ts":
/*!*******************************************************************!*\
  !*** ./src/stress/services/stress-items/StressAdditionService.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../../../shared/Logger */ \"./src/shared/Logger.ts\");\nconst Roll20Util_1 = __webpack_require__(/*! ../../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\n/**\n * StressAdditionService is responsible for adding new {@link StressItem}s to a character.\n *\n * It rolls for new items to add, handles their effect and adds them to a {@link StressedCharacter}s\n * list of stresses.\n */\nclass StressAdditionService {\n    constructor(stressItemManager, chatter) {\n        this.stressItemManager = stressItemManager;\n        this.chatter = chatter;\n    }\n    /**\n     * Add {@link StressItem} to a character. Handles the effect and adds it\n     * to the array of stresses.\n     *\n     * If a StressItem is already present, rather than adding it again, it rolls two new ones,\n     * adds the first one to the current oldest Stress (making it a double) and the second one\n     * to the end of the stress array (making it the newest).\n     *\n     * @param stressUpdate character to remove stresses from, and by what amount\n     */\n    addStressItem(stressUpdate) {\n        Logger_1.Logger.info(`Adding a stress to ${stressUpdate.name}`);\n        const stressToAdd = this.stressItemManager.getRandomStress();\n        if (this.isStressItemAlreadyPresent(stressToAdd, stressUpdate)) {\n            Logger_1.Logger.debug(`Stress ${stressToAdd.name} already present on ${stressUpdate.name}`);\n            stressUpdate = this.addDoubleStress(stressUpdate);\n        }\n        else {\n            stressUpdate = this.addStress(stressUpdate, stressToAdd);\n        }\n        return stressUpdate;\n    }\n    addDoubleStress(stressUpdate) {\n        Logger_1.Logger.info(`Adding double stresses to ${stressUpdate.name}`);\n        // Add the normal stress first so there's always an empty mixin\n        stressUpdate = this.addStress(stressUpdate, this.stressItemManager.getRandomStress());\n        // Mixin the first stress with the current oldest stress that has no mixin yet\n        for (let index = 0; index < stressUpdate.stresses.length; index++) {\n            if (!stressUpdate.stresses[index].mixin) {\n                stressUpdate.stresses[index].mixin = this.stressItemManager.getRandomStress();\n                this.doStress(stressUpdate, stressUpdate.stresses[index].mixin);\n                this.chatter.sendDoubleStressDebuffGainedMessage(stressUpdate, stressUpdate.stresses[index]);\n                break;\n            }\n        }\n        return stressUpdate;\n    }\n    addStress(stressUpdate, stressItem) {\n        this.doStress(stressUpdate, stressItem);\n        stressUpdate.stresses.push(stressItem);\n        this.chatter.sendStressDebuffGainedMessage(stressUpdate, stressItem);\n        return stressUpdate;\n    }\n    isStressItemAlreadyPresent(stressToAdd, stressedCharacter) {\n        return stressedCharacter.stresses.find(stress => stress.id === stressToAdd.id) !== undefined;\n    }\n    doStress(stressedCharacter, stress) {\n        Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromStressItem(stressedCharacter, stress);\n    }\n}\nexports.StressAdditionService = StressAdditionService;\n\n\n//# sourceURL=webpack:///./src/stress/services/stress-items/StressAdditionService.ts?");

/***/ }),

/***/ "./src/stress/services/stress-items/StressRemovalService.ts":
/*!******************************************************************!*\
  !*** ./src/stress/services/stress-items/StressRemovalService.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../../../shared/Logger */ \"./src/shared/Logger.ts\");\nconst Roll20Util_1 = __webpack_require__(/*! ../../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\n/**\n * StressRemovalService is responsible for removing {@link StressItem}s from a character.\n *\n * It removes the oldest (first in Array) stresses on a character based on the amount. When\n * removing it undoes any effect that a StressItem provided.\n */\nclass StressRemovalService {\n    constructor(stressItemManager, chatter) {\n        this.stressItemManager = stressItemManager;\n        this.chatter = chatter;\n    }\n    /**\n     * Remove {@link StressItem}s from a character. Undoes the effect on each and removes them\n     * from the array of stresses.\n     *\n     * Removal is based on first in first out. If we somehow end up in a situation where more stresses\n     * have to be removed than exist in the array this function returns silently.\n     *\n     * @param stressUpdate character to remove stresses from, and by what amount\n     */\n    removeStressItem(stressUpdate) {\n        Logger_1.Logger.info(`Removing stress from ${stressUpdate.name}`);\n        let removedStress = stressUpdate.stresses.shift();\n        if (removedStress) {\n            if (removedStress.mixin) {\n                this.removeDoubleStress(stressUpdate, removedStress);\n            }\n            else {\n                this.removeStress(stressUpdate, removedStress);\n            }\n        }\n        return stressUpdate;\n    }\n    removeDoubleStress(stressUpdate, stress) {\n        if (!stress.mixin) {\n            Logger_1.Logger.error(`Tried to double remove stress on a stress with no mixin`);\n            return;\n        }\n        this.undoStress(stressUpdate, stress);\n        this.undoStress(stressUpdate, stress.mixin);\n        this.chatter.sendDoubleStressDebuffLostMessage(stressUpdate, stress);\n    }\n    removeStress(stressedCharacter, stress) {\n        this.undoStress(stressedCharacter, stress);\n        this.chatter.sendStressDebuffLostMessage(stressedCharacter, stress);\n    }\n    undoStress(stressedCharacter, stress) {\n        Roll20Util_1.Roll20Util.updateNumericalPropertiesWithValueFromStressItem(stressedCharacter, stress, true);\n    }\n}\nexports.StressRemovalService = StressRemovalService;\n\n\n//# sourceURL=webpack:///./src/stress/services/stress-items/StressRemovalService.ts?");

/***/ }),

/***/ "./src/stress/util/StressAbilityCreator.ts":
/*!*************************************************!*\
  !*** ./src/stress/util/StressAbilityCreator.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nconst Roll20Util_1 = __webpack_require__(/*! ../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\nclass StressAbilityCreator {\n    /**\n     * Create the stress buttons for a specified playerCharacter. Creates a +1 and -1 Stress button.\n     *\n     * @param playerCharacter playerCharacter to create the buttons for\n     */\n    createStressAbilityOnCharacter(playerCharacter) {\n        if (this.isStressAbilityPresent(playerCharacter)) {\n            Logger_1.Logger.debug('Stress Ability already present');\n            return;\n        }\n        Logger_1.Logger.info(`Creating Stress ability on ${playerCharacter.name}`);\n        const abilityProperties = {\n            _characterid: playerCharacter.characterId,\n            name: 'Stress',\n            description: 'Modify your stress',\n            action: '!+-stress ?{Amount|0}',\n            istokenaction: true\n        };\n        createObj('ability', abilityProperties);\n    }\n    isStressAbilityPresent(playerCharacter) {\n        return Roll20Util_1.Roll20Util.getAbilityOnCharacter('Stress', playerCharacter.characterId) !== undefined;\n    }\n}\nexports.StressAbilityCreator = StressAbilityCreator;\n\n\n//# sourceURL=webpack:///./src/stress/util/StressAbilityCreator.ts?");

/***/ }),

/***/ "./src/stress/util/StressChatter.ts":
/*!******************************************!*\
  !*** ./src/stress/util/StressChatter.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Chatter_1 = __webpack_require__(/*! ../../shared/Chatter */ \"./src/shared/Chatter.ts\");\nconst Roll20Util_1 = __webpack_require__(/*! ../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nclass StressChatter extends Chatter_1.Chatter {\n    constructor() {\n        super(...arguments);\n        this.welcomeMessage = 'Welcome to the world of stress.';\n        this.instructionOne = 'An ability has been added to your token to control your stress. ' +\n            'You can find it wherever you have your ability buttons when you select your token';\n        this.instructionTwo = 'A handout has been assigned to you. It holds 2 lists.';\n        this.instructionThree = \"1. Your Stress list, I'll keep this one up to date.\";\n        this.instructionFour = \"2. A Perseverence list. I add new Perseverence gained to this, but it's up to you to remove them.\";\n        // TODO build these messages based on multiple attributes\n        this.colorMessageRed = '{{save=1}}';\n        this.colorMessageGreen = '{{weapon=1}}';\n        this.colorMessageBlue = '{{ability=1}}';\n        this.colorMessagePurple = '{{spell=1}}';\n        this.attributeDisplay = '{{{0} = @{{1}|{2}} {0} }}';\n        this.attributeStressBase = '&{template:5eDefault}' +\n            '{{showclassactions=1}}' +\n            '{{title=Stress {0}}}' +\n            '{{subheader= {1} }}' +\n            '{{Effect= {2} }}' +\n            '{{=Updated values}}';\n        this.doubleAttributeStressBase = '&{template:5eDefault}' +\n            '{{showclassactions=1}}' +\n            '{{title=Double Stress {0}}}' +\n            '{{subheader= {1} }}' +\n            '{{Effect #1 = {2} }}' +\n            '{{Effect #2 = {3} }}' +\n            '{{=Updated Values}}';\n        this.perseverenceBase = '&{template:5eDefault}' +\n            '{{showclassactions=1}}' +\n            '{{title=Perseverence {0} }}' +\n            '{{subheader= {1} }}' +\n            '{{Effect= {3} }}' +\n            '{{Description= {4} }}';\n    }\n    sendWelcomeMessage(playerCharacter) {\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerCharacter.playerId), this.welcomeMessage);\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerCharacter.playerId), this.instructionOne);\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerCharacter.playerId), this.instructionTwo);\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerCharacter.playerId), this.instructionThree);\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(playerCharacter.playerId), this.instructionFour);\n    }\n    sendStressChangedMessage(stressUpdate) {\n        stressUpdate.amount = stressUpdate.stressValue - stressUpdate.oldStressValue;\n        if (stressUpdate.amount >= 0) {\n            this.sendStressGainedWhisper(stressUpdate);\n        }\n        else {\n            this.sendStressLostWhisper(stressUpdate);\n        }\n    }\n    sendDoubleStressDebuffGainedMessage(stressedCharacter, stress) {\n        this.sendDoubleStressMessage(stressedCharacter, stress, 'Gained');\n    }\n    sendDoubleStressDebuffLostMessage(stressedCharacter, stress) {\n        this.sendDoubleStressMessage(stressedCharacter, stress, 'Lost');\n    }\n    sendStressDebuffGainedMessage(stressedCharacter, stress) {\n        this.sendStressMessage(stressedCharacter, stress, 'Gained');\n    }\n    sendStressDebuffLostMessage(stressedCharacter, stress) {\n        this.sendStressMessage(stressedCharacter, stress, 'Lost');\n    }\n    sendPerseverenceGainedMessage(stressedCharacter, perseverence) {\n        this.sendPerseverenceMessage(stressedCharacter, perseverence, 'Gained');\n    }\n    sendPerseverenceLostMessage(stressedCharacter, perseverence) {\n        this.sendPerseverenceMessage(stressedCharacter, perseverence, 'Lost');\n    }\n    sendStressGainedWhisper(stressUpdate) {\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(stressUpdate.playerId), `Gained ${stressUpdate.amount} stress. You're now on ${stressUpdate.stressValue} total stress.`);\n    }\n    sendStressLostWhisper(stressUpdate) {\n        this.sendBotWhisper(Roll20Util_1.Roll20Util.getPlayerDisplayNameById(stressUpdate.playerId), `Lost ${stressUpdate.amount} stress. You're now on ${stressUpdate.stressValue} total stress.`);\n    }\n    sendPerseverenceMessage(stressedCharacter, perseverence, type) {\n        let message = this.stringFormat(this.perseverenceBase, type, stressedCharacter.name, '' + stressedCharacter.stressValue, perseverence.name, perseverence.desc);\n        if (type === 'Gained') {\n            message += this.colorMessagePurple;\n        }\n        else {\n            message += this.colorMessageBlue;\n        }\n        this.sendBotAnnouncement(message);\n    }\n    sendStressMessage(stressedCharacter, stress, type) {\n        let message = this.stringFormat(this.attributeStressBase, type, stressedCharacter.name, stress.name);\n        if (type === 'Gained') {\n            message += this.colorMessageRed;\n        }\n        else {\n            message += this.colorMessageGreen;\n        }\n        stress.targetAttributes.forEach(targetAttribute => {\n            message += this.stringFormat(this.attributeDisplay, targetAttribute.name, stressedCharacter.name, targetAttribute.target);\n        });\n        this.sendBotAnnouncement(message);\n    }\n    sendDoubleStressMessage(stressedCharacter, stress, type) {\n        if (!stress.mixin) {\n            Logger_1.Logger.error(`Tried to send doubleStressDebuffLost message for ${stressedCharacter.name}, but mixin was undefined.`);\n            return;\n        }\n        let message = this.stringFormat(this.doubleAttributeStressBase, type, stressedCharacter.name, stress.name, stress.mixin.name);\n        if (type === 'Gained') {\n            message += this.colorMessageRed;\n        }\n        else {\n            message += this.colorMessageGreen;\n        }\n        stress.mixin.targetAttributes.forEach(targetAttribute => {\n            message += this.stringFormat(this.attributeDisplay, targetAttribute.name, stressedCharacter.name, targetAttribute.target);\n        });\n        this.sendBotAnnouncement(message);\n    }\n}\nexports.StressChatter = StressChatter;\n\n\n//# sourceURL=webpack:///./src/stress/util/StressChatter.ts?");

/***/ }),

/***/ "./src/stress/util/StressFileWriter.ts":
/*!*********************************************!*\
  !*** ./src/stress/util/StressFileWriter.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Roll20Util_1 = __webpack_require__(/*! ../../shared/Roll20Util */ \"./src/shared/Roll20Util.ts\");\nconst Logger_1 = __webpack_require__(/*! ../../shared/Logger */ \"./src/shared/Logger.ts\");\nclass StressFileWriter {\n    constructor() {\n        this.handoutName = 'Stress for {0}';\n        // Util\n        this.horizontalLine = '<hr>';\n        // Generic\n        this.currentStress = 'Current stress: {0}';\n        this.listItem = '<li>{0}</li>';\n        // Debuffs\n        this.debuffStart = '<h3>Your debuff list</h3>';\n        this.debufSubStart = '<h5>This list is automatically kept up to date</h5><h5>Oldest debuffs are at the top and will be removed first</h5>';\n        this.listItemWithMixin = '<li>{0} and {1}</li>';\n        this.emptyDebuffListMessage = 'Woo! Stress free';\n        // Perseverence\n        this.perseverenceStart = '<h3>Your perseverence list</h3>';\n        this.perseverenceSubStart = '<h5>Click on the button to remove a used perseverence</h5>';\n        this.emptyPerseverenceList = 'No perseverence buffs active.';\n        this.listItemWithDesc = '<li>{0}: {1} -- <a href=\"!&#13!perseverence {2}\">Consume</a></li>';\n    }\n    /**\n     * Create a blank note for a newly registered {@link PlayerCharacter}.\n     *\n     * @param playerCharacter Character to create the note for. The PlayerId from this is used, as all\n     * handouts have to be associated with a player.\n     */\n    createEmptyStressNote(playerCharacter) {\n        const handoutName = this.stringFormat(this.handoutName, playerCharacter.name);\n        if (this.isHandoutPresent(playerCharacter, handoutName)) {\n            Logger_1.Logger.debug(`Handout Ability already present.`);\n            return;\n        }\n        createObj('handout', {\n            name: handoutName,\n            inplayerjournals: playerCharacter.playerId,\n            controlledby: ''\n        });\n        this.updateStressNoteForStressedCharacter(Object.assign(Object.assign({}, playerCharacter), { stressValue: 0, stresses: [], perseverences: [] }));\n    }\n    /**\n     * Update the name in the title of note. Gets all notes with oldName and updates them to\n     * include the newName.\n     *\n     * This updates the title of **every** Handout that includes the StressedCharacters name and isn't\n     * limited to a single player\n     *\n     * @param oldName name currently on the note title.\n     * @param newName name to set the note title to.\n     */\n    updateStressNoteName(oldName, newName) {\n        const handoutName = this.stringFormat(this.handoutName, oldName);\n        const handouts = Roll20Util_1.Roll20Util.getHandoutsByName(handoutName);\n        if (handouts !== undefined) {\n            handouts.forEach(handout => {\n                handout.set('name', this.stringFormat(this.handoutName, newName));\n            });\n        }\n    }\n    /**\n     * Update the note of Handouts to reflect changes in a StressedCharacters list of stresses\n     * and perseverences. Simply rebuilds the entire note.\n     *\n     * This updates the note of **every** Handout that includes the StressedCharacters name and isn't\n     * limited to a single player.\n     *\n     * @param stressedCharacter character to update the note for.\n     */\n    updateStressNoteForStressedCharacter(stressedCharacter) {\n        const handoutName = this.stringFormat(this.handoutName, stressedCharacter.name);\n        const handouts = Roll20Util_1.Roll20Util.getHandoutsByName(handoutName);\n        if (handouts !== undefined) {\n            handouts.forEach(handout => {\n                handout.set('notes', this.buildNote(stressedCharacter));\n            });\n        }\n    }\n    buildNote(stressedCharacter) {\n        let note = '';\n        note = note + this.stringFormat(this.currentStress, '' + stressedCharacter.stressValue);\n        note = note + this.horizontalLine;\n        note = note + this.debuffStart;\n        note = note + this.debufSubStart;\n        note = note + this.horizontalLine;\n        if (stressedCharacter.stresses.length === 0) {\n            note = note + this.emptyDebuffListMessage;\n        }\n        else {\n            stressedCharacter.stresses.forEach(stress => {\n                if (stress.mixin) {\n                    note = note + this.stringFormat(this.listItemWithMixin, stress.name, stress.mixin.name);\n                }\n                else {\n                    note = note + this.stringFormat(this.listItem, stress.name);\n                }\n            });\n        }\n        note = note + this.horizontalLine;\n        note = note + this.perseverenceStart;\n        note = note + this.perseverenceSubStart;\n        note = note + this.horizontalLine;\n        if (stressedCharacter.perseverences.length === 0) {\n            note = note + this.emptyPerseverenceList;\n        }\n        else {\n            stressedCharacter.perseverences.forEach(perseverence => {\n                note = note + this.stringFormat(this.listItemWithDesc, perseverence.name, perseverence.desc, perseverence.uuid);\n            });\n        }\n        return note;\n    }\n    stringFormat(str, ...args) {\n        return str.replace(/{(\\d+)}/g, (_match, index) => args[index] || '');\n    }\n    isHandoutPresent(playerCharacter, handoutName) {\n        return Roll20Util_1.Roll20Util.getHandoutOnPlayer(handoutName, playerCharacter.playerId) !== undefined;\n    }\n}\nexports.StressFileWriter = StressFileWriter;\n\n\n//# sourceURL=webpack:///./src/stress/util/StressFileWriter.ts?");

/***/ })

/******/ });